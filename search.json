[{"title":"Todo List(2023.05)","url":"/2023/05/07/2023-05-Todo/","content":"嵌入式操作系统\n思考题\n\n复习\n\n期末考试\n\n\n操作系统\n实验报告\n\n课后习题\n\n复习\n\n\n数据库\nmooc\n\n实验报告\n\n大作业\n\n复习\n\n\n计算机网络\nmooc\n\n思科\n\n实验\n\n复习\n\n\nARM\n实验报告\n\n复习\n\n\n英语\nCET6笔试\n\nCET6口试\n\n\n"},{"title":"EOS复习梳理","url":"/2023/05/18/EOS%E5%A4%8D%E4%B9%A0%E6%A2%B3%E7%90%86/","content":"明天要考试了，今天一天看看能不能梳理完嵌入式操作系统的学习内容。\n一、嵌入式操作系统概述这个部分不是重点，看看书上的概念和思考题就好惹。\n二、调度策略这个部分与OS课程有比较多的重合。\n2.1 基本概念任务:相互作用的程序集合或软件实体，每个程序执行时成为任务。\n任务执行的特性\n\n动态性:任务的运行状态不断变化 → 状态变迁图 \n并发性:多任务并发执行 \n异步独立性:任务间相互独立，不存在前驱与后继关系 \n同步性:任务之间非独立，相互依赖\n\n调度点的位置\n中断结束、等待资源、周期起止、…\n时间约束\n\n截止时间:任务必须完成的时间 \n执行周期:任务重复出现并处理完成的时间间隔 \n延迟时间:任务允许等待的时间\n\nRTOS追求的目标:简单、确定性 → 确保实时性约束 \n调度机制: 根据给定调度策略来安排任务的具体执行，如 创建任务、就绪任务、挂起任务、任务间通信、…。\n调度策略: 针对有限的CPU资源，确定哪个任务先执行、 在哪个CPU上执行、执行时间、等等的策略。→ 以调度算 法的形式体现\n调度策略的本质:为任务确定优先级\n调度算法:在特定时刻，确定将要运行的任务的一组规则\n调度机制和调度策略共同完成内核的的调度功能\n周期任务的CPU利用率为$$E_i &#x2F; T_i$$即执行时间&#x2F;周期\n接下来的算法都默认相对截止时间&#x3D;周期，即任务在每个周期都需要完成一次。\n2.2 RMS调度算法周期越短，优先级越高。最好的静态调度算法。\n可调度性判定：\n任务集T可调度的充分条件是$$CPU的利用率 ≤ n(2^{1&#x2F;n}-1)$$其中n为任务个数\n优点：如果一组任务能够被任何静态调度算法所调度，则这些任务在RMS下也是可调度的\n不足：可调度的CPU使用率上限为ln2，如此低的CPU使用率对大多数的系统来说不可接受\n2.3 EDF调度算法可调度性判定：\n任务集T可调度的充分条件是$$CPU的利用率 ≤ 1$$\n2.4 LLF调度算法最短空闲时间优先算法。\n选择松弛度更低的调度。$$松弛度&#x3D;相对截止时间-剩余运行时间$$\n可调度性判定：\n任务集T可调度的充分条件是$$CPU的利用率 ≤ 1$$\n2.5 死锁就是OS课上的内容\n死锁产生的四个条件：\n\n资源互斥\n不可抢占\n请求和保持\n环路等待\n\n预防死锁：防止条件的产生\n银行家算法\n2.6 优先级反转优先级反转\n高优先级任务需要等待低优先级任务释放资源，而低优先级任务又正在等待中等优先级任务执行的现象。\n解决方法\n\n优先级继承：当一个任务在其使用的临界区阻塞了一个或多个高优先级任务时，该任务将不使用其原来的优先级，而使用被该任务所阻塞的所有任务的最高优先级作为其执行临界区的优先级。 当该任务退出临界区时，又恢复到其最初的优先级。（可能造成死锁）\n优先级天花板（不会出现死锁，效率更高，但是会影响某些中间优先级任务的完成时间）\n\n"},{"title":"讲Python","url":"/2023/05/07/Python-Notes-for-Shelly/","content":"可供练习的在线python编译器：\nhttps://c.runoob.com/compile/9/\n更多内容可以参看https://www.runoob.com/python3/python3-tutorial.html\n1.第一个python程序print(&#x27;hello world&#x27;)x = int(input())print(x + 1)\n\n2.变量与表达式\n自由落体公式 h &#x3D; 0.5 * g * t * t，其中g &#x3D; 9.8。对于给定的时间t，输出对应的高度h\n\ng = 9.8t = float(input())#请注意需要将input()进行格式转换t = 0.5 * g * t * tprint(t)\n\n\n输入一个三位数，输出百、十、个位之和。\n\nnum = int(input())a1 = int(num / 100)a2 = num % 100a3 = int(a2 / 10)a4 = a2 % 10print(a1 + a3 + a4)\n\n3.选择控制结构（if- else）\n输入一个数，判断它是奇数还是偶数\n\nnum = int(input())if num % 2 == 0:    print(&quot;偶数&quot;）else:    print(&quot;奇数&quot;)\n\n\n输入一名学生的成绩（0100），成绩在90分及以上输出优秀，成绩在7089之间输出良好，成绩在60~69之间输出及格，低于60的挂科\n\ngrades = int(input())if grades &gt;= 90:    print(&quot;优秀&quot;)elif grades &gt; 70:    print(&#x27;良好&#x27;)elif grades &gt;= 60:    print(&quot;及格&quot;)else:    print(&#x27;挂科&#x27;)\n\n4. 循环控制结构（while, for）\n 理解循环过程\n\n\n\n输入n，在屏幕上输出1~n之间的所有整数（包括n）\n\nn = int(input())i = 1while i &lt;= n:    print(i)    i = i + 1    for i in range(1, n + 1, 1):    print(i)\n\n\n输入一个奇数n，输出1 + 3 + 5 + … + n的结果\n\nn = int(input())sum = 0for i in range(1, n + 1, 2):    sum = sum + i    #即sum = sum + iprint(sum)\n\n\n输入一个整数n，判断其是否为完数 \n完数：除自身外所有因子加起来的和等于自身。 如6 &#x3D; 1 + 2 + 3，则6是完数\n\nn = int(input())sum = 0for i in range(1, n):    if n % i == 0:        sum += iif sum == n:    print(&#x27;是完数&#x27;)else     print(&#x27;不是完数&#x27;)     \n\n\n输入一个整数n，输出1~n（包括n）之间所有的完数\n\nn = int(input())for i in range(1, n + 1):    sum = 0    for j in range(1, i):        if n % i == 0:            sum += i    if sum == i:        print(i)\n\n5.字符串\n定义一个字符串\n\nvar = &#x27;hello world&#x27;var = &#x27;123&#x27;var2 = 123print(var)\n\n\n访问字符串中的值\n\nvar = &#x27;hello world&#x27;print(var[4])print(var[1:5])print(var[-3:])\n\n\n字符串的运算\n\nvar1 = &#x27;hello&#x27;var2 = &#x27;world&#x27;var_sum = var1 + var2var_mul = var1 * 2print(var_sum)print(var_mul)\n\n\n字符串的格式化（format语法的使用）\n\nvar1 = &#x27;khl&#x27;var2 = &#x27;Goblin&#x27;var_new = &#x27;&#123;&#125; is handsome&#x27;.format(var1)print(f&#x27;&#123;var1&#125; is handsome&#x27;)print(&#x27;&#123;0&#125; is handsome, &#123;1&#125; is ugly.&#x27;.format(var1, var2))\n\n6.列表\n创建一个列表\n\nlist1 = [1, 2.2, 3, 4, 6]list2 = [&#x27;khl&#x27;,&#x27;is&#x27;,&#x27;handsome&#x27;]list3 = [&#x27;abcde&#x27;,123,1.44]list4 = [list1, list2, list3]print(list1)print(list2)print(list3)print(list4)\n\n\n访问列表中的值\n\nlist1 = [&#x27;khl&#x27;,&#x27;is&#x27;,&#x27;very&#x27;, &#x27;*&#x27;, 10, &#x27;handsome&#x27;]ele1 = list1[0]ele2 = list1[4]print(ele1, ele2)list2 = list1[2:5]print(list2)#以上部分可以类比字符串#用循环遍历列表list1for i in list1:    print(i)    # i 表示列表中的第i个元素# 等价于for i in range(0, len(list1)):    print(list1[i])    # i 表示列表中的第i个（仅仅代表次序i）    string = list1[0]for i in string:    print(i)    # i 代表字符串中的第i个字符\n\n\n更新列表\n\nlist1 = [&#x27;khl&#x27;,&#x27;is&#x27;,&#x27;very&#x27;, &#x27;*&#x27;, 10, &#x27;handsome&#x27;]list1[4] = 100print(list1)#增加列表内容：append()方法list1.append(&#x27;abcdef&#x27;)print(list1)\n\n\n删除列表元素\n\nlist1 = [&#x27;khl&#x27;,&#x27;is&#x27;,&#x27;very&#x27;, &#x27;*&#x27;, 10, &#x27;handsome&#x27;]del list1[2]print(&#x27;删除后的列表：&#x27;，list1)\n\n\n有关列表的其他方法\n\n#获取列表长度list1 = [&#x27;khl&#x27;,&#x27;is&#x27;,&#x27;very&#x27;, &#x27;*&#x27;, 10, &#x27;handsome&#x27;]print(len(list1))#获取列表中元素最大值/最小值list2 = [111,666,456,777]print(max(list2))print(min(list2))#列表元素排序list3 = [777,666,456,111]list3.sort()print(list3)#字符串切片转列表stmt = &#x27;khl is handsome&#x27;list4 = stmt.split()print(list4)\n\n7.函数函数：function\nY &#x3D; f(x) &#x3D; x + 1\n函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。\n函数结构：\n\n\n编写一个输出’hello world’的函数，并调用\n\ndef helloworld(): #函数名字叫什么都行，括号里是调用函数时传进来的参数，这个函数不需要任何传进来的参数        print(&#x27;hello world&#x27;)    helloworld()\n\n\n传入两个参数，返回两个参数中较小的值\n\ndef get_min(a, b):#传递a, b两个参数进来    if a &lt; b:        return a    else:        return bn = input()m = input()print(get_min(m, n))\n\n\n使用函数，统计输入的5个同学成绩中低于60分的人数\n\ndef count(score):#一个列表变量也可以作为参数传进去    cnt = 0    for i in score:        if i &lt; 60:            cnt += 1    return cnts = []for i in range(0, 5):    s.append(int(input())print(count(s))\n\n\n调用函数，分别统计输入的一组字符串中空格、数字和下划线的数量\n\ndef count(string):    num_cnt, space_cnt, underline_cnt = 0, 0, 0    for i in string:        if i &lt;= &#x27;9&#x27; and i &gt;= &#x27;0&#x27;:            num_cnt += 1        if i == &#x27;_&#x27;:            underline_cnt += 1        if i == &#x27; &#x27;:            space_cnt += 1    return &#x27;空格数为&#123;0&#125;, 数字数为&#123;1&#125;, 下划线数为&#123;2&#125;&#x27;.format(space_cnt, num_cnt, underline_cnt)s = input(&#x27;请输入一个字符串&#x27;)print(count(s))   \n\n\n自定义的函数之间也可以互相调用。\n对于一组数据进行处理，返回其最大值、最小值和平均数\n输入：数据总数n，以及n个数\n\ndef get_sum(data):    sum = 0    for i in data:        sum += i    return sumdef get_min(data):    min = 2147483647    for i in data:        if i &lt; min:            min = i    return mindef get_max(data):    max = 0    for i in data:        if i &gt; max:            max = i    return maxdef func():    n = int(input())    data = []    for i in range(0, n):        data.append(int(input()))    print(&#x27;min:&#x27;,get_min(data))    print(&#x27;max:&#x27;,get_max(data))    print(&#x27;sum:&#x27;,get_sum(data))    func() #注意需要调用主函数 \n\n8.文件操作这个部分主要是介绍一些文件操作的函数（方法），不太需要讲解，到时候复习的时候看看怎么用就好惹。\n9.数据库操作(关系型）数据库：表的集合\n该部分可以类比excel。重点在于理解语句是什么含义。\n\n创建一个数据库（需要定义名称）\n\ncreate database student// 创建一个名为student的数据库\n\n\n创建一个数据库表（定义表头、表名称）\n\ncreate table list (    id, varchar(40) not null,    name, varchar(40),    gender, int,    age, int    )// 创建一个名为list的表，其中每行有id, name, gender, age四个元素；// 其中char或varchar表示字符串，int表示整数，float表示小数\n\n\n添加数据（向刚才的表list中插入一行数据）\n\nINSERT INTO list (id, name, gender, age) VALUES (&quot;2147483647&quot;, &quot;khl&quot;, 1, 20)\n\n\n查找数据（在list表中查找一个name为khl的一行数据）\n\nselect * from list where name = &#x27;khl&#x27;\n\n\n更改数据(将list表中name为khl的学生年龄改为21)\n\nupdate list set age = 21 where name = &#x27;khl&#x27;\n\n10.面向对象在这个部分，我们首先需要了解面向对象的思想方法，这个思想方法主要包含两个方面。\n\n一个对象，包含属性和行为，分别对应一个类里面的变量和方法。\n对象是一个具体的、实例化的概念。与之相对的概念是类。两者是具体和一般的关系。实例化后的对象用一个变量进行存储。\n\n下面是实例：\nclass car:    #创建了一个叫car的类，表示汽车的宽泛概念    def __init__(self, name, age):        # 构造方法，名称不能改，一定是__init__, 意为初始化initialization        # self需要出现在每一个方法中的参数列表中，指代对象自己        # 创建对象时自动执行构造方法        self.name = name        self.age = age        print(&#x27;create successfully&#x27;)                self.run()        self.info()        #可以选择在构造方法中直接执行方法    def run(self):        print(&#x27;&#123;0&#125; is running!!&#x27;.format(self.name))    def info(self):        print(&#x27;name = &#123;0&#125;, age = &#123;1&#125;&#x27;.format(self.name, self.age))    babyhorse = car(&#x27;BMW&#x27;, 30)papy = car(&#x27;benz&#x27;, 4)#创建了两个car的实例化对象，并且在构造方法中自动执行了类中的方法print(babyhorse.name)papy.run()#也可以在外面直接访问对象的方法和属性\n"},{"title":"zx课上的python基础实验","url":"/2023/04/28/zx%E8%AF%BE%E4%B8%8A%E7%9A%84python%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/","content":"计算机网络系统课给的python基础实验。\n四个实验都比较简单，但还是小声BB：zx屁事真**多\n\n1.从命令行读入2至7个二进制数，输出它们的和\n\nimport sysdef reverse(_str):    l = list(_str)    l.reverse()    return &#x27;&#x27;.join(l)   def Add(a, b):    if len(a) &gt; len(b):        a, b = b, a    a, b = reverse(a), reverse(b)    cnt, flag, res = 0, 0, &#x27;&#x27;        while cnt &lt; len(a):        k = int(a[cnt]) + int(b[cnt]) + flag        if k == 0:            res += &#x27;0&#x27;            flag = 0        if k == 1:            res += &#x27;1&#x27;            flag = 0        if k == 2:            res += &#x27;0&#x27;            flag = 1        if k == 3:            res += &#x27;1&#x27;            flag = 1        cnt += 1    while cnt &lt; len(b):        k = int(b[cnt]) + flag        if k == 1:            res += &#x27;1&#x27;            flag = 0        if k == 2:            res += &#x27;0&#x27;            flag = 1        if k == 0:            res += &#x27;0&#x27;            flag = 0        cnt += 1    if flag == 1:        res += &#x27;1&#x27;    return reverse(res)args = sys.argv[1: ]while len(args) &gt; 1:    args.append(Add(args[0], args[1]))    del args[0]    del args[0]print(args[0])\n\n\n\n\n2.词频统计（输入要求和特点略过）\n\nimport reimport sysimport jsondef output(obj):    print(json.dumps(obj))filename, obj= sys.argv[1], &#123;&#125;with open(f&#x27;&#123;filename&#125;&#x27;, &#x27;r&#x27;) as f:    content = f.read()array = re.split(&#x27;[ ,?.!\\n]&#x27;, content)for word in array:    if word != &#x27;&#x27; and word !=  &#x27;\\n&#x27;:        word = word[0].lower() + word[1:]        if word in obj:            obj[word] += 1        else:            obj[word] = 1output(obj)\n\n\n\n\n3.字符串解析（输入要求和特点略过）\n\nimport sysdef parse(s):    res, cnt = &#x27;&#x27;, 0    for letter in s:        if cnt &gt;= 3:            res += &#x27;-&#x27;            cnt = 0        if letter &gt;= &#x27;0&#x27; and letter &lt;= &#x27;9&#x27;:            res += letter            cnt += 1    if res[-1] == &#x27;-&#x27;:        res = res[:-1]    return res + &#x27;\\n&#x27;file1, file2 = sys.argv[1], sys.argv[2]with open(&#x27;&#123;0&#125;&#x27;.format(file1), &#x27;r&#x27;) as fr:    line = fr.readline()    with open(&#x27;&#123;0&#125;&#x27;.format(file2), &quot;w&quot;) as fw:        while line != &#x27;&#x27;:            fw.write(parse(line))            line = fr.readline()\n\n\n\n\n4.json文件和csv文件之间的转换(输入要求和特点略过)\n\nimport jsonimport csvimport sysmode, filename = sys.argv[1], sys.argv[2]file1, file2 = &#x27;&#x27;, &#x27;&#x27;if mode == &#x27;-b&#x27;:    #csv to json    file1 = filename + &#x27;.csv&#x27;    file2 = filename + &#x27;.json&#x27;    with open(f&#x27;&#123;file1&#125;&#x27;, &#x27;r&#x27;) as fr:        content = csv.reader(fr)        with open(f&#x27;&#123;file2&#125;&#x27;, &#x27;w&#x27;) as fw:            _list = []            for row in content:                obj = &#123;&#125;                obj[&#x27;id&#x27;] = row[0]                obj[&#x27;name&#x27;] = row[1]                obj[&#x27;type&#x27;] = row[2]                obj[&#x27;hardware&#x27;] = &#123;&#x27;model&#x27;: row[3], &#x27;sn&#x27;: row[4]&#125;                obj[&#x27;software&#x27;] = &#123;&#x27;version&#x27;: row[5], &#x27;last_update&#x27;: row[6]&#125;                obj[&#x27;nic&#x27;] = [&#123;&#x27;type&#x27;: row[7], &#x27;mac&#x27;: row[8], &#x27;ipv4&#x27;: row[9]&#125;]                obj[&#x27;state&#x27;] = row[10]                _list.append(obj)            json.dump(_list, fw)else:    #json to csv    file1 = filename + &#x27;.json&#x27;    file2 = filename + &#x27;.csv&#x27;    with open(f&#x27;&#123;file1&#125;&#x27;, &#x27;r&#x27;) as fr:        content = json.load(fr)        with open(f&#x27;&#123;file2&#125;&#x27;, &#x27;w&#x27;, newline = &#x27;&#x27;) as fw:            for item in content:                _str = &#x27;&#x27;.join([item[&#x27;id&#x27;], item[&#x27;name&#x27;], item[&#x27;type&#x27;],                             item[&#x27;hardware&#x27;][&#x27;model&#x27;], item[&#x27;hardware&#x27;][&#x27;sn&#x27;],                             item[&#x27;software&#x27;][&#x27;version&#x27;], item[&#x27;software&#x27;][&#x27;last_update&#x27;],                            item[&#x27;nic&#x27;][0][&#x27;type&#x27;], item[&#x27;nic&#x27;][0][&#x27;mac&#x27;], item[&#x27;nic&#x27;][0][&#x27;ipv4&#x27;],                            item[&#x27;state&#x27;]])                fw.write(_str + &#x27;\\n&#x27;)                \n\n"},{"title":"嵌入式OS思考题","url":"/2023/05/08/%E5%B5%8C%E5%85%A5%E5%BC%8FOS%E6%80%9D%E8%80%83%E9%A2%98/","content":"嵌入式操作系统思考题第一组\n什么是嵌入式系统？\n\n嵌入式系统是一种专门设计用于控制某些特定设备或系统的计算机系统。它通常被嵌入于某些特定产品或设备之中，用于控制、监控、管理和处理各种任务和功能，以满足特定的需求和要求。\n嵌入式系统通常具有以下特点：\n\n硬件开发和软件开发相结合，形成一体化的系统；\n\n面向特定应用领域，并且系统资源非常有限；\n\n通常需要高效、实时的响应能力，以满足复杂的控制和处理任务；\n\n\n\n举例说明嵌入式系统应用情况。\n\n\n智能家居：智能家居系统是一种嵌入式系统，它可以控制家庭中的各种设备，如灯光、空调、电视、音响等，通过智能语音或手机APP进行控制，从而提高家居的舒适度和便利性。\n汽车控制系统：现代汽车中的控制系统都是嵌入式系统，包括发动机控制系统、制动系统、安全气囊系统等，这些系统可以实现自动驾驶、智能辅助驾驶、车辆诊断等功能，提高了汽车的安全性和性能。\n医疗设备：医疗设备中的嵌入式系统可以实现各种功能，如心电图仪、血压计、血糖仪等，这些设备可以帮助医生进行诊断和治疗，提高医疗质量和效率。\n工业自动化：工业自动化中的嵌入式系统可以控制各种机器和设备，如机床、机器人等，实现自动化生产，提高生产效率和质量。\n\n\n综述嵌入式系统领域发展情况。\n\n\n技术发展：随着芯片技术、通信技术、传感器技术等的不断发展，嵌入式系统的处理能力、通信速度、数据采集能力等方面得到了很大的提升，使得嵌入式系统在各个领域的应用更加广泛和深入。\n应用领域：嵌入式系统的应用领域越来越广泛，涉及到智能家居、智能交通、医疗设备、工业自动化等各个领域，嵌入式系统已经成为现代化社会不可或缺的一部分。\n开发工具：随着嵌入式系统应用范围的扩大，开发工具也得到了不断的改进和完善，如开发板、集成开发环境、仿真工具等，这些工具可以帮助开发人员更加高效地进行嵌入式系统的开发和测试。\n安全性问题：随着嵌入式系统的普及，安全性问题也逐渐凸显出来，如网络攻击、数据泄露等问题，这些问题需要得到妥善的解决，以确保嵌入式系统的安全性和可靠性。\n\n总之，嵌入式系统领域的发展将会越来越快速和广泛，它将在未来的各个领域发挥更加重要的作用，为人类的生活和工作带来更多的便利和效益。\n\n举例说明嵌入式系统硬件平台的结构和组成，可以如何剪裁配置?\n\n以嵌入式处理器为例，其硬件平台是以嵌入式微处理器为核心，主要由嵌入式微处理器、总线、存储器、I&#x2F;O接口和其他设备（时钟、电源等）组成。\n嵌入式处理器的剪裁配置可以从以下几个方面进行：\n\n处理器架构：嵌入式处理器的架构包括RISC、CISC等。不同的处理器架构适用于不同的应用场景。\n处理器频率：处理器频率是指处理器的时钟速度，通常以MHz或GHz为单位。处理器频率越高，处理器性能越好，但同时也会增加功耗和成本。因此，在剪裁配置嵌入式处理器时，需要根据应用的需求选择适当的处理器频率。\n存储器容量：存储器容量包括内存和闪存两种类型。内存用于存储程序和数据，闪存用于存储系统固件和数据。存储器容量越大，系统的性能和功能越强大，但同时也会增加成本和功耗。因此，在剪裁配置嵌入式处理器时，需要根据应用的需求选择适当的存储器容量。\n通信接口：通信接口包括WiFi、蓝牙等多种类型。不同的通信接口适用于不同的应用场景，如WiFi适用于高速数据传输，蓝牙适用于低功耗设备通信。在剪裁配置嵌入式处理器时，需要根据应用的需求选择适当的通信接口。\n\n\n比较嵌入式处理器与PC处理器的差异。\n\n嵌入式处理器和PC处理器具有以下几个方面的差异：\n\n架构设计：嵌入式处理器通常采用精简指令集（RISC）架构，而PC处理器采用复杂指令集（CISC）架构。RISC架构具有指令简单、执行速度快、功耗低等优点，适合于嵌入式系统的应用场景。CISC架构具有指令复杂、执行速度慢、功耗高等特点，适合于高性能计算机的应用场景。\n处理器性能：嵌入式处理器通常具有低功耗、低成本、小尺寸等特点，适合于嵌入式系统的应用场景。PC处理器通常具有高性能、高功耗、大尺寸等特点，适合于高性能计算机的应用场景。\n外设接口：嵌入式处理器通常具有少量的输入输出接口，适合于嵌入式系统的应用场景；而PC处理器通常具有大量的输入输出接口，如USB、HDMI等，适合于高性能计算机的应用场景。\n系统架构：嵌入式系统通常采用单片机、嵌入式处理器等单一处理器架构，适合于对资源要求较低、功耗要求较低的应用场景。PC系统通常采用多核处理器、GPU等多处理器架构，适合于对性能要求较高、资源要求较高的应用场景。\n应用领域：嵌入式系统通常应用于智能家居、汽车控制系统、医疗设备、工业自动化等领域。PC系统通常应用于桌面电脑、笔记本电脑、服务器等领域。\n\n\n 详细说明两种以上主流嵌入式处理器的特点及实际应用情况.\n\n\nARM Cortex-M系列处理器\n\nARM Cortex-M系列处理器是一种低功耗、高性能的嵌入式处理器，适用于智能家居、汽车控制系统、医疗设备、工业自动化等领域。其主要特点包括：\n\n精简指令集（RISC）架构，指令简单、执行速度快、功耗低；\n支持多种存储器类型，包括闪存、SRAM、EEPROM等；\n支持多种通信接口，包括SPI、I2C、UART等；\n支持多种中断类型，包括外部中断、定时器中断等；\n支持低功耗模式，包括待机模式、休眠模式等。\n\nARM Cortex-M系列处理器的实际应用情况包括：\n\n智能家居：控制智能家居设备，如智能灯泡、智能插座、智能门锁等；\n汽车控制系统：控制汽车发动机、变速器、刹车等系统；\n医疗设备：控制医疗设备，如血压计、血糖仪、心电图仪等；\n工业自动化：控制工业自动化设备，如PLC、工业机器人等。\n\n\nIntel Atom系列处理器\n\nIntel Atom系列处理器是一种高性能、低功耗的嵌入式处理器，适用于智能零售、智能制造、智能交通等领域。其主要特点包括：\n\n复杂指令集（CISC）架构，指令复杂、执行速度快、功耗低；\n支持多核处理，提高系统性能；\n支持多种存储器类型，包括闪存、DRAM、SSD等；\n支持多种通信接口，包括PCIe、USB、Ethernet等；\n支持多种操作系统，包括Windows、Linux等。\n\nIntel Atom系列处理器的实际应用情况包括：\n\n智能零售：控制智能售货机、智能收银机等设备；\n智能制造：控制工业机器人、智能仓储等设备；\n智能交通：控制智能交通信号灯、智能停车场等设备。\n\n\n嵌入式软件运行过程有几个阶段?每个阶段的主要工作是什么?\n\n主要分为六个阶段（含上电复位）。\n\n板级初始化：CPU中堆栈指针寄存器的初始化、BSS段(Block Storage Space)的初始化、CPU芯片级的初始化，中断控制器、内存等的初始化。\n\n引导&#x2F;升级系统：\n系统引导阶段:\nRAM启动。系统软件从NorFlash中读出并加载到RAM中运行: 运行速度较快; 软件可压缩存储在Flash中。\nNorFlash启动。系统软件直接在NorFlash上运行\n外存启动。软件中读取出来加载到RAM中运行，成本低 。\n系统升级阶段:\n远程升级。通过网络; 支持TFTP、FTP、HTTP等方式\n本地升级。使用超级终端或特定的升级软件进行。\n\n系统初始化：操作系统等系统软件运行必需的初始化工作，如根据系统配置完成初始化数据空间、初始化系统所需的接口和外设……的工作。\n\n应用初始化：应用软件运行必需的初始化工作，如应用任务的创建、信号量的创建、消息队列的创建、应用相关的其它初始化……\n\n多任务应用：系统进入多任务状态，操作系统按照已确定的算法进行任务的调度，各应用任务分别完成特定的功能\n\n\n\n什么是BSP？BSP与BIOS有什么异同?\n\nBSP是Board Support Package（板级支持包）的缩写，是一种软件层，提供了与硬件平台相关的驱动程序、操作系统接口、硬件抽象层等功能，以便操作系统和应用程序能够在特定的硬件平台上运行。\nBSP与BIOS有以下异同：\n\n功能不同\n\nBSP提供的是与硬件平台相关的驱动程序、操作系统接口、硬件抽象层等功能，以便操作系统和应用程序能够在特定的硬件平台上运行。而BIOS（Basic Input&#x2F;Output System）则是一种固件，提供了计算机启动时的自检、硬件初始化、系统参数设置等功能。\n\n位置不同\n\nBSP通常是操作系统的一部分，与操作系统一起发布。而BIOS则是计算机硬件上的一块固件芯片，通常由计算机制造商预装在计算机上。\n\n适用范围不同\n\nBSP适用于嵌入式系统和嵌入式设备，可以针对不同的硬件平台进行定制开发。而BIOS适用于个人计算机和服务器等通用计算机，可以在不同的操作系统上运行。\n\n开发方式不同\n\nBSP的开发通常需要硬件平台的相关资料和开发工具，需要针对具体的硬件平台进行开发和调试。而BIOS的开发则需要掌握相关的汇编语言和固件开发工具，需要针对具体的计算机硬件进行开发和调试。\n\n嵌入式操作系统有哪两种引导模式？比较两种引导模式的优缺点。\n\n嵌入式操作系统有两种引导模式：裸机引导和Bootloader引导。\n\n裸机引导\n\n裸机引导是指在嵌入式设备上直接运行操作系统内核，没有任何引导程序的干预。裸机引导的优点是启动速度快，系统资源占用少，适用于资源有限的嵌入式设备。缺点是不够灵活，无法进行系统配置和更新，也无法进行系统恢复和修复。\n\nBootloader引导\n\nBootloader引导是指在嵌入式设备上运行一个小型的引导程序，用于加载操作系统内核和其他系统组件。Bootloader引导的优点是灵活性高，可以进行系统配置和更新，也可以进行系统恢复和修复，有较高的可靠性。缺点是启动速度相对较慢，系统资源占用相对较多。\n\n前后台系统在轮询系统的基础上做了什么改变？其运行方式是什么？它适用于什么嵌入式应用？\n\n前后台系统相比于轮询系统，主要做了以下改变：\n\n引入中断机制\n\n前后台系统引入了中断机制，可以在外部事件发生时立即响应，避免了轮询系统中需要不断查询的情况，提高了系统的响应速度和效率。\n\n前后台结构\n\n前后台系统将任务分为前台任务和后台任务两种，前台任务通常是与用户交互相关的任务，需要及时响应用户的输入；后台任务通常是与硬件控制、数据处理等相关的任务，需要长时间运行。两者宏观上并行。\n前后台系统的运行方式是：系统启动后，前台任务和后台任务分别运行在不同的线程或进程中，前台任务等待用户输入或其他外部事件，后台任务负责处理硬件控制、数据处理等任务。当外部事件发生时，系统会触发相应的中断，调用相应的事件处理函数进行处理。如图所示：\n\n前后台系统适用于计算机与单用户交互、实时I&#x2F;O设备控制的应用的场合下。如工业自动化、智能家居、医疗设备等。\n\n简述ARM9 S3C2440A的中断处理流程。\n\n\n中断CPU当前执行\n保护被中断进程现场\n分析中断原因，转去相应的中断处理程序\n执行中断处理程序\n恢复被中断进程的现场\nCPU继续执行原来被中断的进程\n\n\n结合代码分析：IRQ中断发生后，ARM9 S3C2440如何保护现场？需要保存哪些信息？\n\n需要保存的内容主要是寄存器。\n; 现场保存:r0-r12、LR、CPSR sub lr,lr, #4;由IRQ模式计算返回地址 (1) stmfd sp!,&#123;r0-r12,lr&#125;;保存寄存器和pc (2)mrs r0, cpsr;(3)stmfd sp!,&#123;r0&#125;;保存CPSR (4)\n\n保护现场需要保护寄存器内容，保存寄存器内容和PC、CPSR，其中包含子程序返回地址等信息。\n\n抢占调度和不可抢占调度的区别是什么？RTOS通常采取上述方式的哪一种？其原因是什么？\n\n抢占调度和不可抢占调度的区别在于任务是否可以被强制中断。具体来说：\n\n抢占调度\n\n抢占调度是指在任务执行过程中，如果有更高优先级的任务需要运行，系统会强制中断当前任务，切换到高优先级任务运行。抢占调度可以保证高优先级任务及时运行，但是会增加系统的开销和复杂度。\n\n不可抢占调度\n\n不可抢占调度是指在任务执行过程中，不允许被其他任务中断，直到任务自己执行完毕或者主动让出CPU。不可抢占调度可以减少系统的开销和复杂度，但是可能会导致高优先级任务无法及时运行，影响系统的实时性。\nRTOS通常采取抢占调度的方式。原因是：\n\n抢占调度可以保证高优先级任务及时运行，提高系统的实时性。\n抢占调度可以减少任务的响应时间，提高系统的性能。\n抢占调度可以更好地管理系统资源，避免任务之间的资源竞争和死锁等问题。\n抢占调度可以更好地支持多任务并发执行，提高系统的可扩展性和可维护性。\n\n\n什么是并发性？它和并行性的区别是什么？什么是safety? 它和security的区别是什么？\n\n并发性是指系统能够同时处理多个任务，而并行性是指系统能够同时执行多个任务。并发性和并行性的区别在于，并发性是指多个任务在同一时间段内交替执行，而并行性是指多个任务同时执行。\nSafety是指系统能够在正常操作和异常情况下保持稳定和可靠的能力。例如，一个汽车的安全性包括了避免事故的能力、防止车辆失控的能力、保护乘客的能力等。而Security是指系统能够在面对各种威胁和攻击时保护系统和数据的能力。例如，一个网络系统的安全性包括了保护系统免受黑客攻击的能力、保护用户隐私的能力、保护数据不被窃取的能力等。\n\n与通用操作系统相比，RTOS具有哪些特点？请重点对其中的一点进行详细叙述。\n\n相比通用操作系统，RTOS具有以下特点：\n\n实时性：RTOS的最大特点就是实时性，它能够保证任务在规定的时间内完成，从而满足实时性需求。\n简单：RTOS相比通用操作系统更加简单，它只关注任务的调度和通信，不涉及复杂的系统管理和资源分配。\n可裁剪：RTOS可以根据实际需求进行裁剪，只保留必要的功能，从而减少系统资源占用。\n低延迟：RTOS的任务调度时间非常短，可以保证任务的及时响应，从而降低系统的延迟。\n可靠性：RTOS的可靠性非常高，它能够保证任务的正确执行，从而提高系统的稳定性。\n\n其中，实时性是RTOS最为关键的特点之一。实时性是指系统能够在规定的时间内完成任务。在嵌入式系统中，往往需要处理一些实时性要求较高的任务，如控制系统、通信系统等。如果系统无法在规定的时间内完成任务，就会导致系统失效，从而产生严重的后果。针对实时性要求的不同，实时性可以分为硬实时、软实时和严格实时三类。主流的RTOS需要支持多种实时性。\n第二组\n什么是内核移植？aCoral的移植工作包括哪些内容？\n\n内核移植就是将将内核代码从一种硬件平台转移到另一种硬件平台上运行。\naCoral的移植包括两个部分：一是硬件抽象层(HAL)移植，二是项目移植。\n\nHAL移植：针对不同目标板改写相关代码\n\n项目移植：处理规则不一致的问题\n\n\n\nRTOS内核中与硬件有关的代码通常包括哪几个部分？\n\n通常包括以下5个部分：\n\n启动\n中断\n任务切换\n内存\n驱动程序\n\n\n当ARM9 S3C2410产生复位异常时，软件上需要做什么处理？请结合代码加以描述。\n\n第三组\naCoral优先级通过什么方式定义？aCoral优先级表示与uC&#x2F;OSII有什么不同？\n\naCoral线程优先级通过数组acoral_prio_array表述；用优先级位图数组bitmap[PRIO_BITMAP_SIZE]标识某一优先级是否任务就绪。\naCoral优先级表示与uC&#x2F;OSII的不同点在于aCoral支持线程具有相同优先级的情况，一个优先级可以对应多个线程。\n\n什么是调度机制？什么是调度策略？\n\naCoral将调度分为两层，上层为策略，下层为机制。\n调度策略，就是如何确定线程的CPU、优先级prio等参数。线程按照FCFS、分时或速率单调RM策略来调度，还有对某些线程要进行特殊调度处理，然后根据相应操作来初始化线程。一种策略对应一种线程。\n调度机制就是负责调度策略的具体实施，即根据给定调度策略来安排任务的具体执行。\n\n请叙述aCoral如何创建一个任务，结合一个开源的aCoral，给出aCoral创建任务的流程图，并对其TCB的初始化进行详细解释。\n\n如何创建一个任务：首先为线程分配空间，然后根据创建线程的调度策略对线程TCB进行相关初始化，接着对线程的堆栈进行初始化，最后将创建的线程挂载到就绪队列上，供内核调度。\n流程图：\n详细说明见下：\nacoral_id create_comm_thread(void (*route) (void *args), acoral_u32stack_size, void *args, acoral _char *name, acoral_u8 prio, acoral_8 CRU)acoral_ _comm_policy_data_t policy_ctrl;•acoral threadt *thread;/*分配TCB 数据块*/Enread=acorat_alloc_thread ()：//返回刚分配的TCB 的指针if (NULL==thread)&#123;  acoral_printerr (&quot;Alloc thread:&amp;s fail\\n&quot;, name);  acora__printk (&quot;No Mem Space or Beyond the max thread\\n&quot;);  return -1;&#125;/*为TCB 成员赋值*/thread-&gt;name=name;stack_size=stack_sized&amp;(~3);thread-&gt;stack_size=stack_size;thread-&gt;stack buttom=NULL;/*设置线程要运行的CPU 核心*/POLICY_ctrL.CPU=CPU;/*设置线程的优先级*/  policy_ctri.prio=prio;  policy_ctrl.prio_type=ACORAL_BASE_PRIO;  thread-&gt;policy=ACORAL_SCHED_POLICY_COMM;  thread-&gt;CPU_mask=-1;  return comm_policy_thread_Init (thread, route, args, §policy_ctrl);&#125;\n\n\n\n\naCoral什么时候会触发内核调度程序acoral_sched()的执行？acoral_sched是如何调度任务的？\n\n何时触发：\n\n中断服务程序结束时\n运行任务因缺乏资源而被阻塞时\n任务周期开始或者结束的时刻\n高优先级任务就绪时\n\n如何调度任务：\n从就绪队列中找出最高优先级任务，接着进行任务切换，执行完任务后退出。\n\naCoral的HAL_CONTEXT_SWITCH与HAL_INTR_CTX_SWITCH有什么区别？分别在什么情况下调用？\n\n区别\n\nHAL_CONTEXT_SWITCH只执行了普通的保存旧上下文内容到堆栈、将新上下文内容恢复到寄存器和CPSR等操作；\n而HAL_INTR_CTX_SWITCH处理处于中断环境下的上下文切换，就流程上来说复杂一些：刚进入中断时，将旧的线程的上下文环境保存到中断的堆栈中，而在线程切换时从中断模式栈顶复制环境到旧的线程的堆栈。\n\n适用情况\nHAL_CONTEXT_SWITCH用于非中断方式下的任务切换（也就是任务主动发起的线程切换），而HAL_INTR_CTX_SWITCH用于中断触发的任务切换。\n\n结合代码，说明HAL_INTR_ENTRY在中断响应过程中的作用？它是如何区分不同中断源的？该函数执行过程中进行了几次模式切换？为什么要进行切换？\n\nHAL_INTR_ENTRY代码：\nHAL_INTR_ENTRY\tstmfd sp!, &#123;r0-r12, lr&#125;\tmrs r1, spsr\tstmfd\tsp!, &#123;r1&#125;\tmsr cpsr_c, #SVCMODE|NOIRQ\t\t\t\tstmfd sp!, &#123;lr&#125;\tldr r0, =INTOFFSET\t@注1\tldr r0, [r0]\tmov lr, pc\tldr pc, =hal_all_entry\tldmfd sp!, &#123;lr&#125;\tmsr cpsr_c, #IRQMODE|NOINT\t\tldmfd sp!, &#123;r0&#125;\tmsr spsr_cxsf, r0\tldmfd sp!, &#123;r0-r12, lr&#125;\tsubs pc, lr, #4\n\n作用\nHAL_INTR_ENTRY是IRQ公共入口函数，它是指向所有IRQ的一个公共入口。当各种IRQ发生时，它们都将汇集到HAL_INTR_ENTRY，进行硬件抽象层中断处理。\n区分中断源\n在注1所在的那一行代码中，函数读取中断控制器中INTOFFSET寄存器的值。当某个IRQ发生时，INTOFFSET会为该中断源分配一个整数，该整数唯一地对应于该中断源。这样可以通过读取该寄存器分辨不同的中断源。\n模式切换\n一共进行了两次模式切换。第一次进入了SVC模式，以便允许中断嵌套。第二次进入了IRQ模式，以恢复上下文内容。\n\n什么是任务的上下文切换？在aCoral中，任务上下文切换有哪两种类型?上下文切换的主要内容是什么？请提供aCoral在ARM mini2440上任务切换的代码并进行解释。\n\n任务上下文切换就是从一个线程转移到另一个线程，从底层来看就是改变了PC值。同时，改变PC值还是不够，因为一个线程不仅由PC构建，还有堆栈、寄存器的值等。\n任务上下文切换有以下两种类型：\n\n如果先前的线程处于退出状态ACORAL_THREAD_STATE_EXIT，则调用HAL_SWITCH_TO切入最高级线程\n如果先前的线程并非处于退出状态，则调用HAL_CONTEXT_SWITCH切换到最高优先级进程。\n\n任务切换代码HAL_CONTEXT_SWITCH如下：\nHAL_CONTEXT_SWITCH:   stmfd sp!, &#123;lr&#125;@保存PC   stmfd sp!, &#123;r0 - r12,lr&#125; @保存寄存器LR，及r0-r12   mrs r4, CPSR  stmfd sp!, &#123;r4&#125;@保存cpsr    str sp, [r0]@保存旧上下文栈指针到旧的线程prev-&gt;stack  ldr sp, [r1]@取得新上下文指针   ldmfd sp!, &#123;r0&#125;         msr cpsr, r0\t@恢复新cpsr(不能用spsr，因为sys,user模式没有SPSR)  ldmfd sp!, &#123;r0-r12,lr,pc&#125; @恢复寄存器\n\n其中L(1)L(5)是保存被抢占线程的环境，L(6)L(9)是恢复抢占线程的现场。\n上下文切换的内容如下：\n\n假定任务优先级分为256级，每个级别对应唯一任务，在aCoral如何利用优先级位图法从就绪队列中找到最高优先级任务？能否做到查找时间和队列长度无关的?\n\naCoral线程优先级通过数组acoral_prio_array表述；用优先级位图数组bitmap[PRIO_BITMAP_SIZE]标识某一优先级是否任务就绪。\n具体可以看如下代码：\nacoral_u32 acoral_find_first_bit(const acoral_u32 *b,acoral_u32 length)&#123;\t........  for (off = 0; v = b[off], off &lt; length; off++) &#123;                                    if(v)     // 选择第一个数值不为0的32位bitmap          break;    &#125;    return acoral_ffs(v)+off*32;    //确定最低一位为1的是哪位 &#125;acoral_u32 acoral_ffs(acoral_u32 word)                                          &#123;\tacoral_u32 k;\tk = 31;\tif (word &amp; 0x0000ffff) &#123; k -= 16; word &lt;&lt;= 16; &#125;                                 \tif (word &amp; 0x00ff0000) &#123; k -= 8;  word &lt;&lt;= 8; &#125;                              \t  if (word &amp; 0x0f000000) &#123; k -= 4;  word &lt;&lt;= 4; &#125;                                \tif (word &amp; 0x30000000) &#123; k -= 2;  word &lt;&lt;= 2; &#125;                                 if (word &amp; 0x40000000) &#123; k -= 1; &#125;                                                 return k;&#125;\n\n如上代码所示，aCoral的方法是这样找到最高优先级的任务的：首先选择第一个数值不为0的32位bitmap（最高优先级存在于这个bitmap），再确定该bitmap的最低位为1是哪一位。从而找到最高优先级任务。\n由上述过程可知，查找时间仅与PRIO_BITMAP_SIZE这个事先已定好的量有关，与队列长度无关。\n\n简单叙述aCoral在ARM9 Mini2440上的中断响应流程。重点对响应过程中的acoral_intr_entry()函数进行说明。\n\n中断响应流程：\n\nacoral_intr_entry()代码及说明:\nvoid acoral_intr_entry(acoral_vector vector)&#123;\tacoral_vector index;// HAL层中断号变为内核层中断表号   HAL_TRANSLATE_VECTOR(vector,index);   acoral_intr_nesting_inc(); // 中断嵌套层+1   if(intr_table[index].type == ACORAL_EXPERT_INTR)&#123;// 根据内核层中新中断号，找到对应的中断向量，处理     intr_table[index].isr(vector);\t\tacoral_intr_disable();  \t&#125;else&#123;//这个之前都是要关中断的，调用中断进入函数    if(intr_table[index].enter!=NULL) //需要入口处理      intr_table[index].enter(vector);\t\tacoral_intr_enable(); //开中断：增加调度点    intr_table[index].isr(vector); //调用该中断的服务处理函数    acoral_intr_disable(); //关中断    if(intr_table[index].exit!=NULL)//需要出口处理      intr_table[index].exit(vector);//此时中断表未空\t&#125; acoral_intr_nesting_dec(); //本次中断待结束，嵌套减一  acoral_intr_exit();//退出中断&#125;\n\nacoral_intr_entry()是真正的中断公共服务入口函数。\n\n互斥量和信号量的区别是什么？它们分别用在哪些情况下？\n\n区别\n对于互斥量来说，主要应用于临界资源的互斥访问，并且能够有效避免优先级反转问题。对于信号量而言，它虽然也能用于临界资源的互斥访问，但是不能处理优先级反转问题，也正因为信号量没有考虑优先级反转问题，所以相对于互斥量来说是一种轻量级的实现方式，比互斥量耗费更少的CPU资源；此外，除了用于互斥，还可以用于处理不同线程之间的同步问题，而互斥量却不行。\n适用情况\n\n互斥量：适用于需要互斥访问临界资源的情况，可以有效避免优先级反转问题，但相对较重，耗费更多的CPU资源；\n\n信号量：适用于需要同步不同线程之间的情况，相对较轻，耗费更少的CPU资源，但不能处理优先级反转问题。\n\n\n"},{"title":"操作系统原理课后习题","url":"/2023/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/","content":"第一章\n1.设计现代OS的主要目标是什么？\n\n方便性、有效性、可扩充性和开放性\n\n有效性：1. 提高系统资源的利用率，2.指提高系统的吞吐量，总体表现为操作系统允许以更有效的方式使用计算机系统资源。\n方便性：使计算机更加易于使用\n可扩充性：在操作系统中，允许有效的开发，测试和引进新的系统功能\n开放性：系统可以遵循世界标准规范，实现应用程序的可移植和互操作性，要求具有统一的开放的环境。\n\n\n6.试说明推动分时系统形成和发展的主要动力是什么。\n\n满足用户对人机交互的需求，需求包含人机交互、共享主机两个方面。\n\n8.为什么要引入实时操作系统？\n\n实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致的运行。用户需求一个系统能够及时响应，外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有事实时任务协调一致地运行。实时操作系统正是为了满足用户这样的需求而诞生的。\n\n10.试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。\n\n交互性：在实时控制系统中，人与系统的交互性仅限于访问系统中某些特定的专用服务程序。它不像分时系统那样，能向终端用户提供数据处理、资源共享等服务，进行广泛的人机对话。及时性：分时系统对实时性的要求是依据人所能接受的等待时间确定的，分时系统通常为1～3秒。实时控制系统的实时性则是以控制对象所要求的截止时间来确定的，一般为秒级到毫秒级。可靠性：分时系统要求系统可靠；实时系统要求系统高度可靠，因为任何差错都可能带来无法预料到灾难性后果。\n\n11.OS有哪几大特征？其最基本的特征是什么？\n\n并发、共享、虚拟、异步四大特征，其中最基本的特征是并发。\n\n15.处理机管理有哪些主要功能？其主要任务是什么？\n\n主要功能有：创建和撤销进程，对诸进程的运行进行协调，实现进程之间的信息交换，以及按照一定的算法把处理器分配给进程。主要任务有：进程控制、进程同步、进程通信、调度。\n\n16.内存管理有哪些主要功能？其主要任务是什么？\n\n主要功能有：内存分配与回收、内存保护、地址映射和内容扩充主要任务：为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存。\n\n17.设备管理有哪些主要功能？其主要任务是什么？\n\n主要功能：缓冲管理、设备分配、设备处理以及虚拟设备等主要任务：完成用户进程提出的I&#x2F;O请求，为用户进程分配所需的I&#x2F;O设备，并完成指定的I&#x2F;O操作；提高CPU和I&#x2F;O设备的利用率，提高I&#x2F;O速度，方便用户使用I&#x2F;O设备。\n\n18.文件管理有哪些主要功能？其主要任务是什么？\n\n主要功能：文件存储空间的管理、目录管理、文件的读&#x2F;写管理以及文件的共享和保护功能。主要任务：对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。\n第二章\n试从动态性、并发性和独立性上比较进程与程序。\n\n\n动态性：进程的实质是进程实体的执行过程。因此，进程是动态的，且具有一定的生命期。而程序只是一组有序指令的集合，并存放于某种介质上，其基本并不具有活动的含义，因而是静态的。\n并发性：多个进程实体同存于内存中，且能够在一段时间内同时运行，即程序可以并发。而程序（没有建立PCB）是不能参与并发执行的。\n独立性：在传统的OS中，进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位，进程是独立的。凡未建立PCB 的程序都不能作为一个独立的单位参与运行，不是独立的。\n\n\n试说明PCB的作用具体表现在哪几个方面？为什么说PCB是进程存在的唯一标志？\n\n\n作为独立运行基本单位的标志\n能实现间断性运行方式\n提供进程管理所需要的信息\n提供进程调度所需要的信息\n实现与其他进程的同步与通信\n\n之所以说PCB是进程存在的唯一标志，是因为在进程的生命期中，系统只能通过PCB对进程进行控制，也只能通过PCB得知进程的存在。\n\n试说明进程在三个基本状态之间转化的典型原因。\n\n\n就绪状态 -&gt; 执行状态：通过进程调度，进程被分配到了CPU资源\n执行状态 -&gt; 就绪状态：当前进程的时间片完，或者被更高优先级任务抢占\n执行状态 -&gt; 阻塞状态：I&#x2F;O设备请求或无法获取所需的临界资源\n阻塞状态 -&gt; 就绪状态：I&#x2F;O设备请求完成或获取到所需临界资源\n\n\n在进程切换时，所要保存的处理机状态信息有哪些？\n\n\n程序计数器，存放下一条指令地址\n通用寄存器\n程序状态字中的状态信息，如中断屏蔽标志等\n堆栈指针\n部分状态信息，如处理器模式等\n内存管理信息，如页表、段表\n\n\n引起进程阻塞或者被唤醒的主要事件是什么\n\n\n一个新的事件或操作出现，需要等待该任务执行完毕再接着进行进程。如出现I&#x2F;O请求或者I&#x2F;O结束。\n请求共享资源失败或被分配到共享资源\n等待其他进程的信号或接收到了信号\n\n\n试从调度性、并发性、拥有资源以及系统开销方面对进程和线程进行比较\n\n\n调度性：传统的OS中进程是调度和分派的基本单位。而在引入线程的OS中， 线程是调度和分派的基本单位，是能独立运行的基本单位。线程的调度效率更高。\n并发性：OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，甚至还允许在一个进程中的所有线程都能并发执行 。同样，不同进程中的线程也能并发执行。\n拥有资源：进程是系统中拥有资源的一个基本单位，但仅仅有一点必不可少、能保证独立运行的资源。线程除了拥有自己的少量资源外，还允许多个线程共享该进程所拥有的资源。\n系统开销：在创建或撤消进程时，系统都要为之分配和回收进程控制块、分配或回收其它资源。OS 为此所付出的开销，明显大于线程创建或撤消时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换代价也远低于进程的。\n\n\n何谓用户级线程和内核支持线程\n\n\n用户级线程：用户级线程是在用户空间中实现的。对线程的创建、撒消、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。在一个系统中的用户级线程的数目可以达到数百个至数千个。由 于这些线程的任务控制块都是设置在用户空间，而线程所执行的操作也无需内核的帮助，因而内核完全不知道用户级线程的存在。\n内核支持线程：在OS中的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，是与内核紧密相关的。而内核支持线程KST 同样也是在内核的支持下运行的，它们的创建、阻塞、撤消和切换等，也都是在内核空间实现的。为了对内核线程进行控制和管理，在内核空间也为每一个内核线程设置了一个线程控制块，内核根据该控制块而感知某线程的存在，并对其加以控制。\n\n第三章\n1.高级调度和低级调度的主要任务是什么？为什么要引入中级调度？\n\n主要任务：\n高级调度又称为作业调度或长程调度，其主要功能是根据某种算法，把外存上处于后备队列中的那些作业调入内存。\n低级调度用于决定就绪队列中的哪个进程应获得处理机，然后再由分派程序执行把处理机分配给该进程的具体操作。\n引入中级调度的目的：\n为了提高内存利用率和系统吞吐量\n\n7.说明低级调度的主要功能\n\n\n按某种算法选取进程\n\n保存处理机的现场信息\n\n把处理器分配给进程\n\n\n\n8.在抢占调度方式中，抢占的原则是什么？\n\n\n优先权原则\n\n短作业(进程)优先原则\n\n时间片原则\n\n\n\n9.在选择调度方式和调度算法时，应遵循的准则是什么？\n\n\n面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。\n面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用\n\n\n12.试比较FCFS和SJF两种进程调度算法\n\n先来先服务(FCFS)调度算法\n\n调度过程当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。\n\n\n适用范围FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。\n\n短作业优先(SJF)调度算法\n\n调度过程短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。\n\n适用范围有利于短作业、不利于长作业。\n\n\n\n20.按调度方式可以将实时调度算法分为哪几种？\n\n分为两种：非抢占调度算法和抢占调度算法\n\n27.何谓死锁？产生死锁的原因和必要条件是什么？\n\n死锁是什么\n死锁是指多个进程因争夺资源而造成的一种僵局（相互等待），若无外力作用，它们都将无法再向前推进。\n产生死锁的原因\n产生死锁的原因可归结为：竞争不可剥夺资源引起进程死锁、竞争可消耗资源引起死锁和进程推进顺序不当引起死锁。\n产生死锁的必要条件\n互斥条件；请求和保持条件；不可抢占条件；环路等待条件。\n\n30.银行家算法\n\n可以，详细分析如下：\nRequest0(0, 1, 0) &lt;= Need0(7,4,3);Request0(0, 1, 0) &lt;= Available(3, 3, 2)\n\n此时可以尝试分配该资源：\n\n\n\n资源情况\nMAX\nAllocation\nNeed\nAvailable\n\n\n\nP0\n7 5 3\n0 2 0\n7 3 3\n3 2 2\n\n\nP1\n3 2 2\n2 0 0\n1 2 2\n\n\n\nP2\n9 0 2\n3 0 2\n6 0 0\n\n\n\nP3\n2 2 2\n2 1 1\n0 1 1\n\n\n\nP4\n4 3 3\n0 0 2\n4 3 1\n\n\n\n进行安全性检查，如下表所示。\n\n\n\n资源情况\nWork\nAllocation\nNeed\nWork + Allocation\nFinish\n\n\n\nP1\n3 2 2\n2 0 0\n1 2 2\n5 2 2\ntrue\n\n\nP3\n5 2 2\n2 1 1\n0 1 1\n7 3 3\ntrue\n\n\nP4\n7 3 3\n0 0 2\n4 3 1\n7 3 5\ntrue\n\n\nP0\n7 3 5\n0 2 0\n7 3 3\n7 5 5\ntrue\n\n\nP2\n7 5 5\n3 0 2\n6 0 0\n10 5 7\ntrue\n\n\n得到安全序列&lt;P1, P3, P4, P0, P2&gt;, 系统安全。可以分配该资源。\n\n31.银行家算法\n\n(1)系统此时安全，有安全序列&lt;Po, P3, P4, P1, P2&gt;。\n(2)不能分配，详细分析如下：\nRequest(1,2,2,2) &lt;= Need2(2,3,5,6):Request(1,2,2,2) &lt;= Available2(1,6,2,2):\n\n此时可以尝试分配该资源：\n\n\n\n进程\nAllocation\nNeed\nAvailable\n\n\n\nP0\n0 0 3 2\n0 0 1 2\n0 4 0 0\n\n\nP1\n1 0 0 0\n1 7 5 0\n\n\n\nP2\n2 5 7 6\n2 3 5 6\n\n\n\nP3\n0 3 3 2\n0 6 5 2\n\n\n\nP4\n0 0 1 4\n0 6 5 6\n\n\n\n进行安全性检查，此时(0, 4, 0, 0)不能满足任何进程的资源请求，因此系统不能响应原请求。\n第四章\n2.可采用哪几种方式将程序装入内存？它们分别适用于何种场合？\n\n可以采用以下三种方式将程序装入内存：\n\n绝对装入方式。当计算机系统很小，且仅能运行单道程序时，完全有可能知道程序将驻留在内存的什么位置，此时可以采用绝对装入方式。\n可重定位装入方式。适用于多道程序环境且不允许程序运行时在内存中移动位置。\n动态运行时的装入方式。在多道程序环境中，若程序运行时在内存中移动位置，只能使用该方式。\n\n\n3.何谓静态链接？静态链接时需要解决两个什么问题？\n\n静态链接：在程序运行之前，先将各目标模块以及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。我们将这种事先进行链接的方式称为静态链接。\n需要解决两个问题：\n\n对相对地址进行修改\n变换外部调用符号\n\n\n6.在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？\n\n空闲分区链。为了实现对空闲分区的分配和链接，在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。为了检索方便，在分区尾部重复设置状态位和分区大小表目。当分区被分配出去以后，把状态位由“0”改为“1”，此时，前、后向指针已无意义。\n\n7.为何要引入动态重定位？如何实现？\n\n原因：在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的分区，即使它们容量的总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。若想把程序装入，可采用的一种方法是：将内存中的所有作业进行移动，使它们全都相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时就可把作业装入该区。这种通过移动内存中作业的位置，以把原来多个分散的小分区拼接成一个大分区的方法，称为“紧凑”。由于经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。\n实现：在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时，不需对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可。\n\n12.分区存储管理中常用哪些分配策略？比较它们的优缺点。\n\n\n\n\n策略\n优点\n缺点\n\n\n\n首次适应算法\n优先利用内存中的低地址部分的空闲分区，从而保留了高地址部分的大空闲区，因此为大作业分配大的内存空间创造了条件。\n但是由于低址部分不断被划分，会留下许多难以利用的、很小的空闲分区。\n\n\n循环首次适应算法\n能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销\n但这样会缺乏大的空闲分区。\n\n\n最佳适应算法\n为大作业分配大的内存空间创造了条件。\n每次分配后所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区。\n\n\n最坏适应算法\n产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高。\n使存储器中缺乏大的空闲分区。\n\n\n快速适应算法\n查找效率高。该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。\n在分区归还主存时算法复杂，系统开销较大。该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重。\n\n\n伙伴系统\n分配和回收内存速度快，且不会产生很多小碎片。\n内存利用率不高，分配的内存大小为2的幂，假如只需要65个页面，也需要分配128个页面的块，从而浪费了63个页面，即产生内部碎片。\n\n\n\n\n\n\n\n\n20.为实现分页存储管理，需要哪些硬件支持？\n\n需要有页表、地址变换机构等硬件支持。\n\n22.具有快表时是如何实现地址变换的？\n\n\n通过根据逻辑地址中的页号，查找快表中是否存在对应的页表项。\n\n若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内偏移量，计算出物理地址。\n\n若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中，并计算物理地址。\n\n\n\n26.分页和分段存储管理有何区别？\n\n主要区别如下：\n\n页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。\n\n页的大小固定且由系统决定，因而在系统中只能有一种大小的页面，而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。\n\n分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。\n\n\n第五章\n3.虚拟存储器有哪些特征？其中最本质的特征是什么？\n\n虚拟存储器的特征分别是多次性、对换性、虚拟性、离散性，其中最本质的特征是离散性。\n\n4.实现虚拟存储器需要哪些硬件支持？\n\n主要的硬件支持有：\n\n请求分页的页表机制&#x2F;请求分段的段表机制\n缺页（段）中断机制\n地址变换结构\n\n\n10.在请求分页系统中，应从何处将所需页面调入内存？\n\n可以分成以下三种情况进行：\n\n系统拥有足够的对换区空间。这时可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，便须将与该进程有关的文件从文件区拷贝到对换区。\n系统缺少足够的对换区空间。这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改，则不必再将它们重写到磁盘，以后再调入时，仍从文件区直接调入。但对于那些可能被修改的部分，在将它们换出时便须调到对换区，以后需要时再从对换区调入。\nUNIX方式。由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此，在下次调入时，应从对换区调入。由于UNIX系统允许页面共享，因此，某进程所请求的页面有可能已被其他进程调入内存，此时也就无需再从对换区调入。\n\n\n13.在一个请求分页系统中，采用FIFO页面置换算法时，假如一个作业的页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配给该作业的物理块数M分别为3和4时，试计算在访问过程中所发生的缺页次数和缺页率，并比较所得结果。\n\n当M &#x3D;&#x3D; 3时，缺页9次，缺页率为3 &#x2F; 4；M &#x3D;&#x3D; 4时，缺页10次，缺页率为5 &#x2F; 6。\n比较两者可知，M越大，产生更大的缺页次数（Belady现象）。\n\n18.在请求分页系统中，产生“抖动”的原因是什么？\n\n发生“抖动”的根本原因是，同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。这会使得在系统中排队等待页面调进&#x2F;调出的进程数目增加。显然，对磁盘的有效访问时间也随之急刷增加，造成每个进程的大部分时间都用于页面的换进&#x2F;换出，而几乎不能再去做任何有效的工作，从而导致发生处理机的利用率急剧下降并趋于0的情况。\n\n24.说明请求分段系统中的缺页中断处理过程。\n\n请求分段系统中的缺页中断处理过程描述如下：\n\n根据当前执行指令中的逻辑地址查页表，判断该页是否在主存储器中；\n\n若该页标志为“0”则形成缺页中断，中断装置通过交换PSW让操作系统的中断处理程序占用处理器；\n\n操作系统处理缺页中断的办法是查主存分配表，找到一个空闲的主存块，查页表找出该页在磁盘上位置，启动磁盘读出该页信息；\n\n把从磁盘上读出的信息装入到主存块中；\n\n当页面被装入主存后，修改页表中对应表项，填上该页所占用的主存块并把标志置为“1”，表示该页已在主存储器中；\n\n由于产生缺页中断时那条指令并没执行完，所以在把页面装入之后应重新执行被中断指令。\n如图所示（教材第174页）\n\n\n\n第六章\n5.试说明设备控制器的组成。\n\n设备控制器由以下三个部分组成：\n\n设备控制器与处理机的接口。\n\n设备控制器与设备的接口。\n\nI&#x2F;O 逻辑。\n\n\n具体组成如图所示（来自教材第185页）：\n\n\n6.为了实现CPU与设备控制器间的通信，设备控制器应该具备哪些功能？\n\n设备控制器的基本功能如下：\n\n接收和识别命令 : 在控制器中的控制寄存器，用来存放接收的命令和参数，并对所接收的命令翻译为读，写，格式化等命令。\n数据交换 : 这是指实现CPU与控制器之间、控制器与设备之间通过数据寄存器进行数据交换。\n标识和报告设备的状态 ，状态寄存器反映设备的状态。\n地址识别：够识别它所控制的每个设备的地址，控制器中设置地址译码器。\n数据缓冲：由于I／O设备的速率较低而CPU和内存的速率却很高，故在控制器中必须设置一缓冲器。\n差错控制：设备控制器还兼管对由I／O设备传送来的数据进行差错检测。\n\n\n10.设备中断处理程序通常需完成哪些工作？\n\n中断处理程序主要工作如下：\n\n进行进程上下文的切换\n对处理中断信号源进行测试\n读取设备状态和修改进程状态\n\n中断处理流程如图所示（来自教材第192页）：\n\n\n13.设备驱动程序通常要完成哪些工作?\n\n主要任务是接收上层软件发来的抽象I&#x2F;O要求，如read或write命令，在把它转换为具体要求后，发送给设备控制器，启动设备去执行；此外，它也将由设备控制器发来的信号传送给上层软件。\n主要功能如下：\n\n接收由设备独立性软件发来的命令和参数，并将命令中的抽象要求转换为具体要求\n检查用户I&#x2F;O请求的合法性\n发出I&#x2F;O命令\n及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。\n对于设置有通道的计算机系统，驱动程序还应能够根据用户的I&#x2F;O请求，自动地构成通道程序。\n\n\n16.有哪几种I&#x2F;O控制方式？各适用于何种场合？\n\n有以下四种I&#x2F;O控制方式：\n\n轮询I&#x2F;O方式：适用于结构简单、只需少量硬件的电路。\n中断驱动I&#x2F;O控制方式：适用于具有中断机构、用于处理中低速的I&#x2F;O操作和随机事件的计算机系统。\n直接存储器访问（DMA）I&#x2F;O控制方式：DMA方式适用于具有DMA控制器的计算机系统中，用于高速外设大批量数据传输。\nI&#x2F;O通道控制方式：适用于具有通道程序的计算机系统。\n\n\n18.为何要引入与设备的无关性？如何实现设备的独立性？\n\n为什么：为了使应用程序的通用性和适应性得到提高，系统必须能够实现应用程序中所使用的设备与系统的物理设备无关。\n如何实现：为了实现设备的独立性，应引入逻辑设备和物理设备概念。在应用程序中,使用逻辑设备名请求使用某类设备；系统执行时是使用物理设备名。鉴于驱动程序是与硬件或设备紧密相关的软件,必须在驱动程序之上设置一层设备独立性软件，执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换(为此应设置一张逻辑设备表)并向用户层(或文件层)软件提供统一接口，从而实现设备的独立性。\n\n22.在实现后台打印时，SPOOLing系统为请求I&#x2F;O的进程提供哪些服务？\n\n\n当用户进程请求打印输出时，SPOOLing系统做两件事：① 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中；② 输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。\n\n打印机空闲，输出进程从请求打印队列的队首取出一张请求打印表，根据表中的要求将要打印的数据，从输出井传送到内存缓冲区，再由打印机进行打印。\n\n\n"},{"title":"2022年星辰工作室招新答题","url":"/2022/12/01/%E6%98%9F%E8%BE%B0%E5%B7%A5%E4%BD%9C%E5%AE%A4%E6%8B%9B%E6%96%B0%E9%A2%98/","content":"1.产品了解与基础1.1 产品经理的了解\n\n什么是产品经理？\n\n\n产品经理是专门从事对某一项产品进行企划、管理，着眼于用户与市场需求的职位角色，提供并执行产品策略、推动产品开发、协调产品各部门工作的角色。\n\n\n产品经理的工作有哪些？\n\n\n规划、设计产品；研究市场与竞品；分析用户需求；协调和推动产品开发；监控用户反馈；优化、迭代产品；对产品生命周期和效益负责\n我认为其中最核心的在于研究用户并分析用户需求\n\n\n产品经理应该具备什么能力？\n\n\n决策能力、沟通能力、学习能力、项目管理能力、市场&#x2F;用户的调研分析能力、产品规划能力、互联网思维、一定的产品技术能力\n自我情绪调节能力和自我激励能力、具备责任心和团队精神\n\n\nB端产品经理是什么？C端产品经理又是什么？\n\n\nB即Business，是企业或商家。B端产品经理的业务面向企业或组织，对B端产品负责。而B端产品主要帮助企业或组织解决经营管理类问题，提高企业或组织的效率，降低成本。B端注重业务流程，主要任务是满足工作需求，需要针对性地对企业内部流程进行深入了解。\nC即Consumer，是大众用户。C端产品经理的业务面向一般消费者，对C端产品负责。而C端产品往往直接对接一般消费者，直接为消费者和用户提供产品服务体验，比如微博、微信等。C端注重用户体验，注重用户数量、核心用户转化率等指标。\n\n\nPRD是什么？好的PRD应该有什么特点？\n\n\nPRD即Product Requirement Document，产品需求文档。\nPRD文档是供产品开发、设计、测试人员乃至其他项目负责人阅读的，因此好的PRD文档应该具备以下特点：（0）内容完整（1）表达通顺易懂 （2）逻辑清晰明确 （3）突出重点 （4）避免错误与歧义 （5）可检验，有理有据\n\n\n你是从何种途径了解到星辰工作室的？你加入星辰工作室的初衷是什么？你为何希望加入星辰工作室产品组？并简述你眼中你选择进入星辰产品组同你未来职业发展及人生规划之间的联系。\n\n\n通过同学告知和校内的招新广告栏了解到的星辰工作室\n加入星辰工作室的初衷主要是提升自身能力，主要包括锻炼能力、开拓视野、积累经验以及和志同道合的伙伴一起交流。\n我对产品从无到有、从有到优的过程有比较浓厚的兴趣。在大一一整年的项目实践中，我认识到一个项目的关键不在于如何编码实现、算法性能如何等（当然这些也非常重要），而在于项目的idea，也就是做个什么样的项目和产品。一个不匹配任何用户需求、没有具体实际用途的项目，性能再好也不具有价值。而一个产品项目中的人员，不论是否产品经理，都应该具备一定的产品思维，理解自己的产品任务职责、有头脑地完成自己的任务。主要是因为自己的这些兴趣以及观念，我想加入贵工作室的产品组。\n目前，我有意向成为一名产品经理。软工专业的学习可以使我积累一定的项目技术，加入贵工作室的产品组也有助于我“上道”。不论如何，我相信这段产品学习经历对未来从事互联网行业会有积极作用。\n1.2 产品基础\n从产品角度梳理出清水河畔的产品框架，尝试将它整理为思维导图；并提出清水河畔现有的问题及相应的解决策略。要求：条例清晰，如有需要可附相应的文字说明；自加功能请标注，并标明你添加ta的原因。\n\n图片略。\n我认为清水河畔是一个比较完整的校园社区&#x2F;论坛产品，我想提出的可能并不算“现有的问题”，而是产品的一个附加功能。\n清水河畔有一个二手专区板块，而我本人在此之前其实主要是通过QQ群“你电二手物品交易群”获取的二手交易信息。这样的情况下，实现两个平台的交易信息整合有利于便利同学们二手物品的交易操作。因此，我希望通过设置一个QQ群bot，同步将二手专区板块信息发布到相关QQ群，以及将QQ群消息进行爬取同步转发到论坛。具体操作上需要考虑二手交易消息发布的格式问题，应该对交易信息作格式上的规范。\n同理，生活信息中的其他板块与上述情况类似，可以考虑采取相同办法进行功能上的优化。\n2.产品思维与能力测试2.1 产品思维【必做】\n\n\n你最喜欢的一款app或网站是什么？你觉得ta吸引你的点是什么？你能找到一款该app的同类产品吗？ta和你喜欢的app有什么异同？\n\n\n最喜欢的一款app是简讯，一款提供碎片化随机知识的浅阅读app。最吸引我的点在于可以帮助我在碎片时间了解自己领域外的知识。知识推送的随机性与当下流行的“个性化推荐”背道而驰，站在用户的角度，这有助于我打破所谓的“信息茧房”。\n同类产品如知乎。相同点在于都以资讯&#x2F; 知识获取作为主要功能。\n不同点在于：1.用户扮演的角色 。知乎偏向是一个资讯社区，用户是主要的信息提供者，也是信息的接收者；在简讯中信息是由系统随机以10篇为一组推送给用户的，用户主要担任信息接收者这一种角色。2.信息内容与质量。这也与上一点有千丝万缕的联系。在知乎上，只要不违法，用户可以随意发表言论，导致信息良莠不齐。简讯的信息经过筛选，信息质量更好。3.信息获取自由度。知乎上信息获取自由度更高，用户通过热榜、推荐等模块以及搜索功能获取信息；而简讯中信息获取只能系统的推送。 4.功能不同。知乎可以作为信息检索平台，用户可以有目的性地搜寻有用的信息。而简讯是碎片时间的知识获取，作用在于有意义地打发零碎时间。\n\n\n你觉得微信和QQ有什么区别？\n\n\n1.用户年龄不同。QQ用户年龄偏低，微信主要面向工作人士和中老年人。\n2.QQ偏向社交性（陌生人主页点赞、QQ空间可供访问、主页展示更丰富、早些年的兴趣部落、搜索群聊关键词并添加等），微信比较注重隐私性（朋友圈点赞、评论仅显示认识的人、群聊无法搜索添加）与生活性（依托公众号、小程序等为用户提供生活服务）。\n3.软件设计风格不同。QQ界面设计与功能更复杂，装扮、展示等功能更花哨（符合年轻人），而微信界面设计简约，功能精简，没有装扮、分组等功能。\n4.软件操作逻辑不同。以左右滑动为例，在微信中仅可以切换底部操作栏；在QQ中既可以切换到个人主页，也可以选择消息列表中的一个单位进行删除、置顶等操作。\n5.平台体验不同。QQ诞生于PC时代，目前仍可以使用QQ号以及密码登录；微信偏向移动IM通讯，PC端登录仍需手机扫码。\n\n\n如果给微信增加一个功能，你打算增加什么样的功能，请具体阐述功能、使用场景以及原因。\n\n\n我希望增加订阅号的分组与批量管理功能。\n用户可以根据自身需求自定义分组，分类放置订阅号，并且可以进行批量屏蔽消息或批量取关。原因是目前的订阅号功能复杂、质量良莠不齐，人们订阅公众号的原因也不相同。有的公众号作为工具（如银行公众号查询余额），有的公众号作为阅读内容来源，有的公众号是为了满足自己或他人的利益需求……订阅公众号的二维码随处可见，而人们也在不知不觉中关注了几十上百个公众号，不断接受着来自公众号的“信息轰炸”，部分人因此不愿打开消息列表中订阅号消息这一板块。分组与批量管理公众号有利于人们不至于陷入“信息轰炸”，间接增加人们点击订阅号信息的意愿。\n\n\n从产品到项目须经历较长的时间周期，做“产品”和做“项目”本身也是分不开的。请从生命周期，具体实施事件，产出物等角度，具体分析做产品和做项目之间的异同，并简要对比产品经理与项目经理之间的区别。\n\n\n生命周期：做产品的落脚点在项目的规划、实现、维护直到没落的过程，因此生命周期相对更长。而做项目着眼于完成一个既定的目标，因此生命周期相对更短。\n具体实施事件：相同点在于实施事件时都需要团队合作、日程规划、提高效率等。不同点在于，做产品的过程中需要有更多地探索、调整以及创新。而做项目时就有既定目标，更注重如何高效、有质量地完成任务。\n产出物：产品与项目的产出都是为了满足需求。产品的产出物考虑用有限的资源去满足更多需求、追求更多的效益；而项目的产出物是定制的，目标是明确的，是为了满足某一个特定需求的。\n产品经理与项目经理：产品经理着眼于做正确的决策（做什么），关注的是产品是否尽可能地满足市场需求、获取更多的效益；而项目经理着眼于如何将事情做得完美（怎么做），关注的是在有限的时间、成本、资源下完成目标。\n【选做】\n\n\n分享一下你眼中的共享单车市场。\n\n\n共享单车距问世已有七八年，有稳定的市场需求，庞大的用户群体、以及生活在城市中的每一个人都有可能成为用户的潜力，产品生命力仍然旺盛。随着城镇汽车保有量越来越高、交通道路状况越来越复杂、私家车限行政策越来越严格，结合共享单车便利的骑行和停放方式，共享单车已经成为了一种无可替代的交通方式，具有无可估量的社会效益。投放在共享单车上的广告也有比较广泛的社会传播。 \n对于我这个在沙河校区的学生而言，共享单车是有股价的。校园里有哈啰、青桔、美团三种单车，数量维持着动态平衡。买了其中一个品牌的月卡，就相当于入手一支股票。看到自己开卡的品牌单车数量多时，不仅出行更加方便，心情也会非常愉悦。相对的，当你看到只有你开卡品牌的单车没有的时候，是非常苦恼的。这背后反映了一种供求关系。入市有风险，开卡需谨慎（狗头）。\n\n\n微信红包为什么不能被撤回？为什么IM软件几乎都不允许转发语音消息？\n\n\n微信红包为什么不能被撤回：\n首先思考一个问题，为什么要撤回微信红包？有以下几种原因：1.发错人了。2.发错数了。3.发出去以后又不想发了。这些原因都是用户的主观错误。而撤回微信红包总的来说是为了给用户的主观错误提供一个弥补的机会。那问题的关键是在于弥补用户的错误吗？不是，问题的关键在于不让用户犯错误，也就是事前给用户足够多的提示，防止用户犯错。而这一点上微信红包做得非常到位。以转账功能举例，点击后会在页面上部出现收款方昵称、头像、对应微信支付的真实姓名，并等待输入转账金额。输入后点击确认，会出现支付密码&#x2F;指纹确认界面，上面仍然会显示收款方昵称。可以说，每一步都将转账信息传达到位。至于发出去之后又不想发了，这跟人际交往中的送礼一样，送出去想要回来，那只能说是个人主观问题，跟微信无关，没有必要因此推出红包撤回功能。\n其次，从用户体验角度思考为什么不能撤回红包。如果人家已经领了，你撤回了，收款方本来到手的钱没了，心情也会不爽。不仅如此，如果说人家刚把钱花出去你才撤回，收款方余额不够又很难办。一来二去对于收款双方甚至软件开发都比较难办。如果人家没领，你撤回了，这个倒无伤大雅。不过微信本身也支持24小时不收款自动退回。这种情况下撤不撤回似乎问题不大。如果发在群里的红包，只有部分人领了，你撤回了，那么另一部分没领到的人心里同样不爽。也就是说，撤回红包大多数情况下会造成不良的用户体验。\n为什么IM软件几乎都不允许转发语音消息：\n转发是一种特殊的传播行为。传播行为是要符合现代网络规范、不触犯法律底线的，是要受到监管的。\n图片、文字相比于语音消息更容易被监管，人们更容易及时判断并处理。平台对于文字和图片的识别难度不高、准确率可以保障，可以对不良消息进行屏蔽，维护网络环境。\n但是语音不一样，世界上有多种语言，同一种语言还因为地域差异诞生了不同的方言，识别和监管都具有非常大的难度。直截了当地禁止转发语音消息，有利于平台的监管、大众的监督、网络环境的净化乃至社会秩序的保障。\n2.2 能力测试假设你在星辰工作室工作时遇到了以下的情况，请写出你的解决方法。\n\n\n【实践题】甲方想增加一个功能，实现在微信小程序中，展示后台设置的文章内容、并能够进行排版，对小程序的会员用户可以看到全部内容、对非会员用户只能看到第一页内容。但是合同已经签订，产品部分的需求文档开发文档都已经定稿，而且也不知道此次团队中的开发人员技术上能不能实现，如果这个产品是你负责的话，你想怎么去解决这个问题呢？\n\n\n上述功能对软件的根本结构框架没有多大的改变。既然需求文档已经定稿，合同已经签订，那么先根据定稿版本进行开发和推出。同时与开发团队成员积极沟通，了解该功能是否能够实现，将该功能作为下一个version，更新需求文档和开发文档。并且基于时间成本和人员成本（可能要找更多开发人员），请求经费补充和支持。（依据经费的多少决定下一个版本的推出时间 doge ）\n\n\n【实践题】这是一个真实的实战项目，具体请查看文档。要求： 通过组织的背景理解客户需求，并设计满足客户需求的产品，产出产品功能架构设计方案（不需要对每个功能进行详细的设计）。选择1-2个具体的产品方向完成产品设计：项目管理、志愿者管理、课程研发、数据管理等。产出形式：思维导图，文档（选择一个即可）。\n\n\n略。\n3.自己的产品：ComAna主流社交平台评论可视化分析工具1. 总体说明1.0 本部分目标读者开发人员、测试人员、项目经理、Boss、赞助商\n1.1 修订历史\n\n\n日期\n版本号\n说明\n作者\n\n\n\n2022.11.26\n1.0\n第一次拟定PRD文档\n孔翰林\n\n\n\n\n\n\n\n\n1.2 项目概述现代网络平台数据量庞大，内容繁杂。而人们对于自己感兴趣的话题或视频有从总体上把握评论风向的需求。\nComAna是一个评论数据可视化工具，主要针对主流社交平台（知乎、B站、豆瓣等），部署在网页端一段时间后再开发移动端。\n该工具旨在帮助用户获得评论区的数据分析，主要包含情感指数分析、ip属地统计、词频统计、时间曲线统计。成为用户获取信息的帮手，降低数据分析的门槛，提高网络资源的利用效率。\n1.3 功能范围前端网页部分\n\n提供平台选项供用户选择，并跳转\n接收用户输入的编号，送至后端\n（若数据有误）提示输入信息有误\n请求后端获取数据统计结果\n展示数据统计图\n\n后端交互部分\n\n接收前端的编号\n对编号的正确性进行判断\n获取分析数据并传至数据分析模块\n整理分析数据并返送前端\n\n数据分析部分\n\n情感指数分析\n评论时间分析\nip属地统计\n词频统计\n\n1.4 用户范围\n\n\n角色\n特点\n职能\n\n\n\n普通用户\n非专业者，有获取评论数据分析的需求或兴趣（如学生做实践研究或闲来无事看看分析结果等）\n使用工具，输入对应编号（如视频bv号），获取数据统计\n\n\n数据分析人员\n获取数据需求较大，对数据统计有较高要求\n使用工具节约时间，输入对应编号，认真看数据统计图\n\n\nComAna\n本产品\n根据用户输入的编号进行反应（若编号正确可以获取到数据则进行分析统计）\n\n\n1.5 词汇表\n\n\n词汇\n含义\n\n\n\nComAna\n产品名\n\n\nNLP\n自然语言处理\n\n\n词频\n某一词语在文本样本中出现的频率\n\n\n情感指数\n对文本样本进行情感分析后得出的分数，分数越高，情感越积极\n\n\n时间曲线\n评论时间统计，展示为曲线图\n\n\nip属地\n评论者机器ip地址归属地\n\n\n1.6 非功能需求\n可支持平台的扩展性。网络平台众多，有很多平台的数据具有分析价值，而在产品上线前，在有限的时间内难以覆盖所有主流平台。因此，产品应在后续迭代时进行可支持平台数量的增加。\n数据监控需求。后台统计用户使用ComAna工具倾向于分析哪个平台，根据数据调整前端的排序。\n性能需求。考虑到需要使用NLP技术分析大量数据，需要对数据量作出一定限制，在三分钟内将分析出的数据返送到前端。\n\n1.7 其他说明后续版本可以考虑区分非专业与专业数据分析，增加数据分析模块的更多细节，部分内容需收费等，增加商业价值。\n2.UC部分2.0 本部分目标读者开发人员 ，测试人员，项目经理\n其中前端开发人员需要参与所有用例，后端开发人员重点参考第三个用例\n2.1 整体说明ComAna是工具类产品，主要功能是进行评论区数据可视化。\n2.2  UC正文2.2 UC正文2.2.1 UC_&lt;选择目标网站&gt;用例概述\n\n\n用例概述\n内容\n\n\n\n业务描述\n不同用户的目标平台不同，需要在首页选择特定目标平台\n\n\n需求描述\n向用户展示选项以及功能，如何使用一目了然，界面简洁美观\n\n\n行为者\n工具使用者\n\n\n前置条件\n用户对评论区整体数据感兴趣，有数据分析的需求\n\n\n后置条件\n跳转至目标平台对应的编号输入界面\n\n\n其他说明\n后续根据使用热度对选项重新排序。新加入的可支持平台放到《其余可支持平台》的列表中\n\n\n界面描述（原型图）略\n业务描述\n上方框架区域在所有网页都会展示\n后续若要加入广告区需要考虑界面整洁性\n\n流程描述暂时无法在飞书文档外展示此内容\n2.2.2 UC_&lt;输入对应编号&gt;用例概述\n\n\n用例概述\n内容\n\n\n\n业务描述\n用户需要指定特定评论区（通过输入编号的形式）\n\n\n需求描述\n在页面中显示用户所选择的目标网站，并为用户提供一个输入框，键入对应视频&#x2F;问题&#x2F;微博编号\n\n\n行为者\n工具使用者\n\n\n前置条件\n用户通过首页选择目标网站\n\n\n后置条件\n若编号有效，则跳转至可视化数据展示界面；否则提示用户重新输入\n\n\n其他说明\n\n\n\n界面描述（原型图）略\n业务描述\n键入编号后，若编号无效，则弹出提示框提示重新输入\n用户可以通过上方链接区跳转指定链接\n\n2.2.3 UC_&lt;可视化数据展示&gt;用例概述\n\n\n用例概述\n内容\n\n\n\n业务描述\nComAna工具最终的功能，用户想要看到的内容\n\n\n需求描述\n提供对应评论区的情感指数、ip属地统计 、词频统计、评论时间统计与词云图\n\n\n行为者\n工具使用者\n\n\n前置条件\n用户输入有效编号，耐心等待\n\n\n后置条件\n过程结束\n\n\n其他说明\n用户可以通过上方链接跳转至其他网页重新使用工具\n\n\n界面描述（原型图）略\n业务描述\n提供的图表随着鼠标移动产生一定变化与特效\n可视化所用的数据需要有一定数量限制，否则不仅会对目标服务器产生负担，还会使等待时间很长\n\n4.回顾与反思\n什么是产品经理？这次请说一下你经过这么久的历练后，有什么不同的思考哦？\n\n\n产品经理是专门从事对某一项产品进行企划、管理，着眼于用户与市场需求的职位角色，提供并执行产品策略、推动产品开发、协调产品各部门工作的角色。\n经过将近一个月的产品学习，不同的思考在于，产品经理不仅仅是一个职业，也代表了一种看待问题、解决问题的思路：问题-&gt;需求-&gt;规划-&gt;组织-&gt;实现-&gt;维护。\n同时，做了这么久的题，我越发深刻地认识到，产品经理的核心工作形式是文档人柱力。不是所有会写文档的人都是产品经理，但产品经理一定非常会写文档。\n\n\n有没有什么想问星辰工作室的？\n\n\n比较好奇产品组的日常，以及工作室接手一个项目后是如何运作的呢？\n\n\n参加过哪些有趣的线下项目？是否组织策划过这些项目？\n\n\n有趣的线下项目嘛，话心的心理活动哈哈，跟朋友们一起做手工的过程很有意思。高中参与组织过元旦班会这种（形式比较简单哈哈），大学里当了一年在社联干活的工具人（每次活动搬搬道具维持纪律什么的。）\n\n"},{"title":"My First Blog","url":"/2022/12/01/My-First-Blog/","content":"What’s up guys, this is my first blog.\n From now on, I am a blogger.\nprint(&#x27;Hello World!&#x27;)\n\n\n\n主题使用指南：\nhttps://keep-docs.xpoet.cn/advanced/friend-link.html\n"}]